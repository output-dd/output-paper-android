\chapter{Konzept und Implementation}\label{ch:konzept}

Im Folgenden sollen die in \Cref{ch:grundlagen} beschriebenen Grundlagen und Entwurfsmuster genutzt werden und um anhand der in \Cref{ch:analyse} analysierten Komponenten ein Konzept sowie die dazugehörige Implementierung vorzustellen.

\section{Top-Level-Architektur}

Um die in \Cref{se:problem} aufgeführten strukturellen Problemen beheben zu können, wurde zu Beginn der Arbeit eine geeignete Ordner- und Applikationsstruktur festgelegt. Mit der Grundlage der erstellten Dialoglandkarte aus \Cref{se:map} und der Kenntnis der Datenbank-Framework aus \Cref{se:framework} konnte eine Top-Level-Architektur-Modell (TLA) erstellt werden. Dabei werden die verschiedenen Aspekte der Anwendung weitestgehend unabhängige Komponenten unterteilt, die separat entwickelt werden können. Entsprechend dieser Unterteilung ließen sich die folgenden Komponenten ableiten, die anschließend in eigenen \texttt{Packages} implementiert wurden:

\begin{itemize}
    \item Im Root-Verzeichnis des Repositories befinden sich Konfigurationsdateien des Build-Tools Gradle sowie Hilfsdateien, die nicht direkt zur Codebasis der App gehören. Außerdem befindet sich an dieser Stelle das Applikationsverzeichnis.
    \textbf{de.outputdd.android} beinhaltet in der obersten Applikationsebene globale Klassen, wie die \texttt{OutputApplication}, \texttt{MainActivity} und \texttt{GameService} Klasse. Diesen bilden die Basis der Applikation und stellen notwendige Funktionalität bereit, welche in allen Bereichen der App genutzt wird, wie unter anderem die Instanziierung der Repository-Objekte.
    \item \textbf{de.outputdd.android.common} stellt eine Reihe von Komponenten und Erweiterungen bereit, welche die bestehende Android-Bibliothek ergänzen, beispielsweise eine Ansammlung von \texttt{Extensions}\footnote{Extensions \url{https://kotlinlang.org/docs/extensions.html}} welche häufig wiederverwendet werden um die Lesbarkeit und Komplexität des Quellcodes zu verbessern.  
    \item \textbf{de.outputdd.android.game} umfasst die Funktionalitäten der Gamification. Dabei stehen generische Klassen für verschiedene Aufgaben-Typen des OUTPUT-Spiels bereit.
        \begin{itemize}
            \item \textbf{de.outputdd.android.game.observer} enthält alle für das Spiel eingesetzten Aufgaben, die eine Nutzer erfüllen kann. Diese werden von eigenständigen Klassen implementiert.
        \end{itemize} \newpage
    \item \textbf{de.outputdd.android.ui} ist die mächtigste Komponente, da sie die Fragmente aller Ansichten der App sowie die dafür notwendigen Views und Adapter kapselt. 
        \begin{itemize}
            \item \textbf{de.outputdd.android.ui.adapter} besteht aus generischen Klassen, welche in vielen Ansichten wiederverwendet werden um die \texttt{RecyclerView}\footnote{RecyclerView. \url{https://developer.android.com/guide/topics/ui/layout/recyclerview}}- sowie \texttt{Viewpager2}\footnote{Viewpager2. \url{https://developer.android.com/training/animation/screen-slide-2}}-Instanzen der App zu konfigurieren. Hinzu kommen eine Reihe von Binding-Adaptern\footnote{Binding-Adapter. \url{https://developer.android.com/topic/libraries/data-binding/binding-adapters}} die das Konzept von \texttt{Databinding} aus \Cref{subsec:databinding} um eigene Attribute erweitert.
            \item \textbf{de.outputdd.android.ui.dialog} umfasst die Dialog-Ansichten der App, welche als \texttt{BottomSheetDialogFragment}\footnote{BottomSheetDialogFragment. \newline \url{https://material.io/develop/android/components/bottom-sheet-dialog-fragment}} umgesetzt wurden.
            \item \textbf{de.outputdd.android.ui.feed} stellt alle Twitter-Funktionalitäten bereit, inklusive der Timeline-Ansicht und der Möglichkeit, neue Tweets zu erstellen.
            \item \textbf{de.outputdd.android.ui.game} beinhaltet alle Ansichten, die im Zusammenhang mit dem OUTOUT-Spiel stehen, darunter die Spieler-Registrierung, die Fortschrittsansicht und die Rangliste.
            \item \textbf{de.outputdd.android.ui.home} realisiert die Home-Ansicht der App, welche als Verknüpfung zwischen den verschiedenen Ansichten dient.
            \item \textbf{de.outputdd.android.ui.info} stellt die Ansichten der Info-View zur Verfügung, darunter die Lizenz-Ansicht, Danksagung aber auch die Informationen des Crowd-Monitorings und des Datenschutzes.
            \item \textbf{de.outputdd.android.ui.map} ist verantwortlich für die Kartenansicht der App, inklusive der Heatmap, Stände und Eroberungen.
            \item \textbf{de.outputdd.android.ui.program} beinhaltet den Veranstaltungsplan der Messe. Neben der Übersicht lassen die Beiträge auch nach Kategorie und Freitextsuche filtern. Eine Detailansicht gibt die vollständigen Informationen einer Veranstaltung wieder.
            \item \textbf{de.outputdd.android.ui.scan} realisiert die Ansicht des QRCode-Scanners und der damit verbundenen Auswertung von gescannten Codes.
            \item \textbf{de.outputdd.android.ui.tutorial} stellt das App-Tutorial zur Verfügung, um dem Nutzer nach Installation der App in die verschiedenen Ansichten einzuführen.
            \item \textbf{de.outputdd.android.ui.widget} bietet eigene View-Klassen, die in den verschieden Layouts genutzt werden und die bestehenden View-Klassen der Android Bibliothek um weitere Funktionen ergänzen.
        \end{itemize}
\end{itemize}

\newpage

\section{Programmier-Richtlinien}

Um das Projekt bestmöglich auf die Weiterentwicklung vorzubereiten wurden eine Reihe von Vorkehrungen getroffen. 
\newline Da die Android-App potenziell von mehreren Nutzern auf den verschiedenen Betriebssystemen entwickelt werden kann, wurde eine entsprechende Konfigurationsdatei ergänzt, welche dafür sorgt, dass die Quellcode-Dateien über konsistente Zeilenenden verfügen. Anhand einer \texttt{.gitattributes}-Datei im Root-Verzeichnis des Repository werden Dateien beim \enquote{Checkout} von Git automatisch konvertiert. Dadurch können fehlerhafte Änderungs-Anzeigen vermieden und zugleich eine potenzielle Fehlerquelle ausgeschlossen werden.\newline Um jede Datei mit einem deskriptiven Kommentar auszustatten, wurde sich im Projektteam für die Einführung eines Copyright-Hinweis entschieden. Um Diskrepanzen zwischen dem Dateinamen und dem Hinweis zu verhindern, wurde im Rahmen des Projektes ein Copyright-Template erstellt, um anschließend im Projekt eingebunden und auf alle Dateien angewendet werden zu können. Wie in \Cref{fig:copyright} dargestellt, enthält das Copyright-Template zusätzlich zu Hinweisen und Links über die Herkunft des Quellcodes auch einen Link zu den Richtlinien der Weiterentwicklung. Das Template ist dabei bewusst so ausgelegt, dass sich mehrere Autoren inklusive ihrer Kontaktinformationen eintragen können. Letzteres ist wichtig, da sich im Projektteam noch nicht auf eine Lizenzierung der Apps unter Open-Source-Lizenzen festgelegt wurde und daher der Quellcode unter das Kopierrecht des Autors fallen. Wenn eine Weiterverwendung des Codes über den ursprünglich dafür bestimmten Rahmen stattfindet, so können die Autoren hierüber kontaktiert werden.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{copyright.png}
    \caption{Copyright-Template der App.}\label{fig:copyright}
\end{figure}

Um die Probleme der Codequalität der vorhergehenden App zu vermeiden, wird das in Android-Studio integrierte Analyse und Formatierungs-Werkzeug genutzt, um die Codequalität aufrechtzuerhalten. Diese wird bei jedem Commit geprüft und dem Entwickler als Warnung anzeigt. Zukünftige Entwickler sind dazu angehalten diese Meldungen nicht zu ignorieren, sondern ihnen stattdessen Aufmerksamkeit zu schenken und entsprechende Verbesserungen durchzuführen. Durch das Interaktions-Menü welches in Android Studio integriert ist, wird es dem Entwickler erleichtert, auf Feedback einzugehen und Anpassungen schnell und unkompliziert durchzuführen.

\newpage

\section{Umsetzung der Ansichten}

Mit der vorliegenden Konzeption zur Unterteilung der Komponenten und den etablierten Richtlinien begann die Umsetzung der Ansichten. Die Implementation der Ansichten fand dabei zunächst unabhängig vom Datenbank-Backend statt. Stattdessen wurden Beispieldaten verwendet, um die Views zu generieren. Gleichzeitig wurde allerdings bereits großer Wert auf die Strukturierung der ViewModels gelegt, um im späteren Verlauf die Beispieldaten auf einfache Weise durch das Datenbank-Backend ergänzen zu können. Dadurch ergaben sich die Vorteile im Entwicklungsprozess, da die Ansichten in einem schnelleren Entwicklungszyklus erstellt werden konnten und die notwendige Separation leichter umsetzbar war. Im Folgenden konnte bereits nach wenigen Wochen die Benutzeroberfläche zwischen der iOS und Android App abgeglichen werden.

\subsection{Erstellung von Fragments}\label{sub:fragments}

Um die in \Cref{subsec:viewbinding} und \Cref{subsec:databinding} vorgestellten Konzepte von Viewbinding und Databinding zu Nutzen, empfiehlt die offizielle Dokumentation\footnote{Viewbinding in Fragments. \url{https://developer.android.com/topic/libraries/view-binding\#fragments}} die Nutzung von \texttt{Backing-Properties}\footnote{Backing-Properties. \url{https://kotlinlang.org/docs/reference/properties.html\#backing-properties}} in Kotlin.Dabei entsteht inhärent eine gewisse Verbosität. Damit diese Umstände vermieden werden konnte, wurde eine entsprechende Lösung anhand der Klasse \texttt{AutoClearedValue} eingeführt. Diese Klasse beobachtet einfach den Lebenszyklus des Fragments und invalidiert Zugriffe, sobald sich das Fragment im \texttt{onDestroy}-Status befindet. Mittels einer \texttt{Extension}\footnote{Extension. \url{https://kotlinlang.org/docs/extensions.html}} konnte die Verwendung der Klasse über \texttt{Delegated Properties}\footnote{Delegated Properties. \url{https://kotlinlang.org/docs/reference/delegated-properties.html}} bereitgestellt werden. Anhand des in \Cref{subsec:delegation} beschrieben Pattern von Delegation kann die entsprechende Variable in die Nutzung innerhalb der Fragment-Klasse eingebunden werden. Da es sich im Allgemeinen empfiehlt während der \texttt{onCreateView} eines Fragments nur äußerst sparsame Operationen vorzunehmen und stattdessen komplexe Anwendungslogik in die \texttt{onViewCreated} auszulagern, ergibt sich folgender Aufbau der Ansichten:

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{fragment.png}
    \caption{Ausschnitt des Quellcodes des Home-Fragments.}\label{fig:fragment}
\end{figure}

\newpage

In \Cref{fig:fragment} zu sehen ist ein Ausschnitt des Quellcodes der Home-Ansicht. Dabei zu sehen ist die Nutzung des in \Cref{subsec:delegation} vorgestellten Prinzips von Delegation zur Bereitstellung der Klassen-Member. Neben der Verwendung der Methode \texttt{autoCleared()} zur Erstellung einer Instanz der Klasse \texttt{AutoClearedValue} wie oben beschrieben, ist auch die Delegation zur Erstellung von ViewModel-Instanzen zu sehen. Dies geschieht mittels der Methoden \texttt{viewModels()} und \texttt{activityViewModels()} die als Teil von Android KTX\footnote{Android KTX \url{https://developer.android.com/kotlin/ktx}} bereitstehen.

\subsection{Verwendung von Viewmodels}\label{sub:viewmodel_usage}

Für die Bereitstellung von Daten mittels des entwickelten Datenbank-Frameworks wurde Kotlin \texttt{Coroutines}\footnote{Coroutines. \url{https://kotlinlang.org/docs/coroutines-overview.html}} zurückgegriffen. Couchbase bietet die Möglichkeit zur Erstellung von sogenannten \texttt{Live Query}\footnote{Live Query. \newline \url{https://docs.couchbase.com/couchbase-lite/current/android/learn/java-android-query-live.html}} Objekten. Dabei wird ein \texttt{Listener} auf einer beliebigen Datenbankabfrage abgewendet. Sobald sich im Folgenden das Resultat der Datenbankabfrage ändert, wird ein entsprechender \texttt{Callback} ausgeführt. Diese Funktionalität wurde seitens des Datenbank-Frameworks gekapselt und im Allgemeinen unter den \texttt{addOnChangeListener}-Funktionen der Repository-Klasse zur Verfügung gestellt. Des Weiteren lässt sich diese Callback-basierte Asynchronität in einen asynchronen Datenfluss umwandeln. Kotlin führt dazu im Rahmen von \texttt{Coroutines} eine Datenstruktur für die Verwendung von asynchronen Datenfüssen namens \texttt{Flow}\footnote{Asynchronous Flow. \url{https://kotlinlang.org/docs/flow.html}} ein. Das Prinzip eines solchen Datenflusses ist äquivalent zu bekannten Lösungen wie \texttt{RxJava}\footnote{RxJava \url{https://github.com/ReactiveX/RxJava}}. Damit bietet \texttt{Flow} die Grundlage für asynchrone und Event-basierte Programmierung in Kotlin. Ein großer Vorteil von \texttt{Flow} ist das die Verarbeitung von Elementen ausgesetzt werden kann und in diesem Zustand den Main-Thread der Applikation, welcher für die UI zuständig ist, nicht blockiert. Ein weiterer Vorteil von \texttt{Flow}s ist diese sogenannte \enquote{cold streams} repräsentieren. Dabei werden Elemente erst transferiert, sobald ein entsprechender Empfänger vorhanden ist und diese verarbeitet. Im Falle der Android-App bedeutet dieser Sachverhalt, das Objekte erste bei entsprechender Ansicht in App von der Datenbank geladen werden. Die Verarbeitung der Elemente eines \texttt{Flow} geschieht wie auch die Ausführung einer \texttt{Coroutine} in einem entsprechenden Kontext. Dieser Kontext ist verantwortlich für die Koordination der Ausführung. Für den \texttt{CoroutineContext} stehen in der Android-Platform potenziell mehrere Optionen zur Verfügung, die für unterschiedliche Anwendungsszenarien geeignet sind. 

\begin{itemize}
    \item \textbf{Dispatchers.Default} bildet den Standardwert, welcher automatisch genutzt wird, sollte kein anderer \texttt{CoroutineContext} explizit angegeben werden. Dieser Kontext sollte nur zu Testzwecken genutzt werden und die explizite Zuweisung eines Kontext bevorzugt werden.
    \item \textbf{Dispatchers.Main} führt \texttt{Coroutines} auf dem Main-Thread der Applikation aus, der für die UI zuständig ist. Normalerweise handelt es sich hierbei um einen einzelnen Thread, der die Aufgaben sequentiell bearbeitet. Im Falle von Android sollte stattdessen die Benutzung von \texttt{Dispatchers.Main.immediate} bevorzugt werden.
    \item \textbf{Dispatchers.Main.immediate} ist eine Erweiterung des \texttt{Dispatchers.Main} der lediglich auf der JVM und Android nutzbar ist. Dabei werden Aufgaben unverzüglich ausgeführt. Dieser Kontext sollte daher für Operationen genutzt werden, die im direkten Zusammenhang mit der UI stehen, wie beispielsweise die Durchführung eines HTTP-Request zur Registrierung des Spielers. \newpage
    \item \textbf{Dispatchers.Unconfined} gibt keine Aussage über die Ausführung. Stattdessen wird der aktuelle Thread für die Ausführung genutzt ohne jegliche Richtlinien zu setzen. Dieser unspezifische Kontext sollte ebenso vermieden werden.
    \item \textbf{Dispatchers.IO} führt Aufgaben auf einem Hintergrund-Prozess aus. Das kann Vorteilhaft sein um blockierende Aufrufe wie das Lesen von Dateien oder den Zugriff auf die Datenbank durchzuführen. Der Kontext verwendet dazu einen geteilten \enquote{Pool} von Threads die für die Ausführung herangezogen werden. Weitere Threads können bei Bedarf erstellt und nach Verwendung zerstört werden. 
\end{itemize}

Entsprechend ergibt sich für die Verwendung von \texttt{Coroutines} in ViewModels die Nutzung von \textbf{Dispatchers.Main.immediate} für die Deklaration von Methoden, welche direkt von der View aufgerufen werden sollen sowie \textbf{Dispatchers.IO} für Generierung eines \texttt{Flow}, welcher eine konstante Aktualisierung von Elemente (wie den Events der Programm-Ansicht) im Hintergrund ausführen soll. \newline Um die Elemente eines solchen Datenstroms anschließend nutzen zu können, werden diese in ein \texttt{LiveData}\footnote{LiveData. \url{https://developer.android.com/topic/libraries/architecture/livedata}}-Objekt konvertiert. \Cref{fig:viewmodel} zeigt die daraus resultierende Definition eines ViewModels in der App.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{viewmodel.png}
    \caption{Erstellung von ViewModels für die OUTPUT-App.}\label{fig:viewmodel}
\end{figure}

Die \texttt{LiveData}-Objekte können im folgenden genutzt werden, um die Ansichten zu erstellen. Dabei werden die Objekte nach dem in \Cref{sub:observer} beschriebenen Observer-Entwurfsmuster überwacht. Sobald sich im Folgenden die Daten dieser Objekte ändert, wird eine Aktualisierung der Ansicht durchgeführt. Dies geschieht im Falle der Verwendung von \hyperref[subsec:databinding]{Databinding} automatisch wie in \Cref{fig:fragment_viewmodels} anhand des \texttt{PlayerViewModel} zu sehen, welches automatisch die Spielansicht aktualisiert oder im Falle einer Listenansicht durch die Weitergabe der Objekte durch das Fragment, wie in \Cref{fig:fragment_viewmodels} anhand des \texttt{GameRewardViewModel} zu sehen. Bei letzterem geschieht die Generierung der Darstellung einzelner Elemente wie in \Cref{fig:databinding} zu sehen.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{fragment_viewmodels.png}
    \caption{Nutzung von ViewModels für die OUTPUT-App.}\label{fig:fragment_viewmodels}
\end{figure}

\subsection{Definition der Ansichten}

Mittels der in \Cref{sub:fragments} und \Cref{sub:viewmodel_usage} vorgestellten Konzepte und Implementierungen konnten die Ansichten der App definiert werden. \Cref{fig:fragment_viewmodels} zeigt die 5 Hauptansichten der App. Weitere Ansichten wurden entsprechend der Dialoglandkarte aus \Cref{se:map} umgesetzt. Der Aufbau der Ansicht orientiert sich an der Implementation der vorangegangenen Jahre. Allerdings wurde im Rahmen der Neuimplementation auch eine Modernisierung der Benutzeroberfläche durchgeführt. Darunter ergeben sich auch neue Funktionen wie ein dunkles Design, welches automatisch durch die Systemeinstellung des Nutzers aktiviert wird und bei Dunkelheit die Augen vor zu viel Helligkeit schützt. Außerdem wurde eine Reihe von Animationen eingeführt, welche die Nutzererfahrung steigern und die Nutzerinteraktion unterstützen. Im Sinne der Grundprinzipien des Usability Engineerings wurde ebenso auf die Platzierung von Interaktionselementen in der unteren Hälfte des Bildschirms geachtet, um für den Nutzer leichter erreichbar zu sein. Für eine konsistente Nutzererfahrung sorgt auch die Modularisierung von UI-Komponenten sowie die Erstellung von generischen Klassen, welche für mehrere Ansichten in der App wiederverwendet wurde. Zur Bereitstellung eines Themes wurde auf ein Theme der \texttt{Material Design}\footnote{Material Design. \url{https://material.io/resources/build-a-material-theme}} Bibliothek als Grundlage zurückgegriffen, um dem Nutzer eine plattformspezifische Erfahrung zu bieten. Gleichzeitig wurde bei der Auswahl der Formen, Farben und Fonts auf die Vorgaben aus der OUTPUD.DD Corporate Identity geachtet. Neben der Neuimplementation des gesamten UI, inklusive komplexerer Ansichten wie die \enquote{Reward-Ansicht} mit einer Konfetti-Animation, wurde in der Kartenansicht \texttt{Google Maps} durch \texttt{Mapbox}\footnote{Mapbox \url{https://www.mapbox.com/}} ersetzt, da das Mapbox-Framework durch seine Nutzerfreundlichkeit und einfachen Handhabung im Projektteam befürwortet wurde. Auch die Twitter-Ansicht wurde erneuert. Statt der Verwendung des mittlerweile eingestellten Twitter-Frameworks wurde eine rein auf HTML basierende Lösung entwickelt. Dabei wird ein HTML-Template in einer \texttt{Webview}\footnote{Webview. \url{https://developer.android.com/reference/android/webkit/WebView}} dargestellt. Durch diese Implementierung wird kein API-Schlüssel benötigt und konnte zugleich eine zukunftssichere Lösung geschaffen werden.

\newpage

\section{Anbindung der Gamification}

\section{Integration und Testen}
